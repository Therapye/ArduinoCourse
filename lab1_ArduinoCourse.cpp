/*
 *  <Wire.h> це базова бібліотека Arduino для роботи з інтерфейсом I2C, вона відповідає за фізичну передачу даних по двох дротах SDA і SCL, і саме головне, що без неї контролер не зможе комунікувати ні з годинником, ні з дисплеєм

 *  <RTClib.h> це бібліотека для роботи з модулями реального часу, вона перетворює складні дані з чіпа DS1307 у зрозумілий нам час, тобто години, хвилини, секунди

 *  <Adafruit_GFX.h> це просто універсальна графічна бібліотека, вона містить математику для малювання ліній, кіл, квадратів та загалом виведення тексту

 *  <Adafruit_SSD1306.h> загалом це драйвер/біблеотека спеціально для контролера дисплея SSD1306, вона бере графіку від Adafruit_GFX і надсилає правильні команди саме на OLED-екран, щоб засвітити потрібні пікселі

 */


#include <Wire.h>               // для зв'язку I2C
#include <RTClib.h>             // для модуля годинника DS1307
#include <Adafruit_GFX.h>       // базова графіка
#include <Adafruit_SSD1306.h>   // драйвер OLED екрану

// створюємо об'єкт для роботи з годинником
RTC_DS1307 rtc; 

// Horn pin
const int buzzer = 3; 

// Налаштувуємо розмір екрану ( значення у пікселях )
#define SCREEN_WIDTH 128 
#define SCREEN_HEIGHT 64 

/* Створюємо об'єкт дисплея 
  &Wire вказуємо використовувати апаратний (hardware) I2C
  -1 означає що у дисплея немає окремого піна Reset
*/
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// мелодія програвання на кожній хв
// масив частот нот у Hz, 0 означає паузу.
int melody[] = {
  2637, 0, 2637, 0, 2637, 0, 2093, 2637, 0, 3136, 0, 0, 0,
  1568, 0, 0, 0,
  2093, 0, 0, 0,
  1568, 0, 0, 0,
  1319, 0, 1319, 0, 1319, 0, 1568, 2093, 0,
  1760, 0, 0, 0,
  1568, 0, 0, 0
};

// масив тривалості кожної ноти, у мілісекундах
int noteDurations[] = {
  125, 50, 125, 50, 125, 50, 125, 125, 50, 125, 50, 200, 100,
  125, 100, 100, 100,
  125, 100, 100, 100,
  125, 100, 100, 100,
  125, 50, 125, 50, 125, 50, 125, 125, 50,
  125, 100, 100, 100,
  125, 100, 100, 100
};

// Змінні для неблокуючого відтворення музики, загальна ідея щоб екран не зависав під час гри (коротше кажучи без delay)
bool melodyPlaying = false;  // булева змінна чи грає зараз мелодія
unsigned long noteStart = 0;  // час початку ноти
int currentNote = 0;       // номер ноти, яка зараз грає

// функція запуску мелодії з початку
void startMelody() {
  melodyPlaying = true;   // включаємо режим відтворення
  currentNote = 0;          // скидаємо лічильник нот на першу
  noteStart = millis();  // запам'ятовуємо поточний час як старт
}

// головна функція музики, яка викликається постійно, аля Non-blocking, бо arduino не може одночасно грати музику, і змінювати час на дисплеї
void updateMelody() {
  // Якщо музика вимкнена нічого не робимо, виходимо з функції
  if (!melodyPlaying)
  {
    return;
  } 

  unsigned long nowMs = millis(); // отримуємо поточний час

  // перевіряємо чи пройшов час звучання поточної ноти (множимо на 1.3, щоб зробити невелику паузу між нотами)
  if (nowMs - noteStart >= noteDurations[currentNote] * 1.3) 
  {
    currentNote++; // переходимо до наступної ноти

    // якщо дійшли до кінця масиву мелодії
    if (currentNote >= sizeof(melody) / sizeof(int)) 
    {
      melodyPlaying = false; // зупиняємо відтворення
      noTone(buzzer);   // вимикаємо звук фізично
      return;
    }

    //граємо нову ноту
    int note = melody[currentNote];
    if (note > 0) 
    {
      tone(buzzer, note); // якщо частота > 0, видаємо звук
    } 
    else 
    {
      noTone(buzzer); //якщо 0, робимо паузу в музиці
    }
    noteStart = nowMs; // оновлюємо таймер для нової ноти
  }
}

// іконки, які змінюються кожні 2 сек
// PROGMEM означає, що масив зберігається у Flash-пам'яті ( там де і код впринципі ), а не в оперативній RAM. Це економить пам'ять, бо картинки займають багато місця
const unsigned char icon_square[] PROGMEM = {
  // тут записані байти, які формують малюнок квадрата (1 піксель світиться, 0 ні)
  0xFF,0xFF,0xFF,0xFF, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01,
  0x80,0x00,0x00,0x01, 0x80,0x00,0x00,0x01, 0xFF,0xFF,0xFF,0xFF
};

const unsigned char icon_triangle[] PROGMEM = {
  0x00,0x00,0x00,0x00, 0x00,0x00,0x80,0x00, 0x00,0x00,0x80,0x00, 0x00,0x01,0x40,0x00,
  0x00,0x01,0x40,0x00, 0x00,0x02,0x20,0x00, 0x00,0x02,0x20,0x00, 0x00,0x04,0x10,0x00,
  0x00,0x04,0x10,0x00, 0x00,0x08,0x08,0x00, 0x00,0x08,0x08,0x00, 0x00,0x10,0x04,0x00,
  0x00,0x10,0x04,0x00, 0x00,0x20,0x02,0x00, 0x00,0x20,0x02,0x00, 0x00,0x40,0x01,0x00,
  0x00,0x40,0x01,0x00, 0x00,0x80,0x00,0x80, 0x00,0x80,0x00,0x80, 0x01,0x00,0x00,0x40,
  0x01,0x00,0x00,0x40, 0x02,0x00,0x00,0x20, 0x02,0x00,0x00,0x20, 0x04,0x00,0x00,0x10,
  0x04,0x00,0x00,0x10, 0x08,0x00,0x00,0x08, 0x08,0x00,0x00,0x08, 0x10,0x00,0x00,0x04,
  0x10,0x00,0x00,0x04, 0x20,0x00,0x00,0x02, 0x3F,0xFF,0xFF,0xFE
};

void setup() {
  Wire.begin();      // запускаємо шину I2C
  pinMode(buzzer, OUTPUT); 

  // ініціалізуємо дисплей, 0x3C це адреса дисплея, SSD1306_SWITCHCAPVCC тип живлення дисплея
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  
  display.clearDisplay();  // очищаємо буфер дисплея
  display.setTextSize(2);  // розмір шрифту
  display.setTextColor(SSD1306_WHITE); // колір тексту

  // перевірка зв'язку з годинником
  if (!rtc.begin()) {
    display.setCursor(0, 0);
    display.print("RTC Error!");
    display.display();
    while (1); // зациклюємо код тут назавжди, бо якщо не підключений буде годинник, далі піде в loop, і буде зчитувати хтозна що
  }

  // перевірка, чи йде годинник
  if (!rtc.isrunning()) {
    // якщо годинник зупинився, то встановлюємо час компіляції скетчу
    // F(__DATE__) та F(__TIME__) беруть час з комп'ютера в момент завантаження коду
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }
}


void loop() {
  // отримуємо поточний час з модуля
  DateTime now = rtc.now();

  //логіка запуску мелодії
  // якщо секунди дорівнюють 0, тобто початок хвилини, і музика ще не грає
  if (now.second() == 0 && !melodyPlaying) {
    startMelody(); // то даємо команду почати грати
  }

  updateMelody();  //викликаємо функцію керування нотами

  //відображення на екрані
  display.clearDisplay(); // очищаємо екран перед малюванням нового кадру
  display.setCursor(0, 0); // ставимо курсор у лівий верхній кут

  // виводимо години, якщо менше 10 додаємо 0 спереду (щоб було не 9, а 09)
  if (now.hour() < 10)
  { 
    display.print("0");
  }
  display.print(now.hour());
  display.print(":");
  
  // так само хвилини
  if (now.minute() < 10) 
  {
    display.print("0");
  }
  display.print(now.minute());
  display.print(":");
  
  // і секунди
  if (now.second() < 10) 
  {
    display.print("0");
  }
  display.print(now.second());


  int iconX = 48; // X для малюнка
  int iconY = 16; // Y для малюнка

  // умова , щоб виводило тільки на парних секундах 
  if (now.second() % 2 == 0) 
  {
    //ділимо секунди на 2, якщо результат парний буде квадрат, непарний то буде трикутник.
    if ((now.second() / 2) % 2 == 0) 
    {
      display.drawBitmap(iconX, iconY, icon_square, 32, 32, SSD1306_WHITE);
    } 
    else 
    {
      display.drawBitmap(iconX, iconY, icon_triangle, 32, 32, SSD1306_WHITE);
    }
  }

  // виводимо все, що ми намалювали в пам'яті вище
  display.display(); 
}